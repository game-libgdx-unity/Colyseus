"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const Protocol_1 = require("../Protocol");
const Errors_1 = require("./../Errors");
const Debug_1 = require("./../Debug");
const Utils_1 = require("../Utils");
class Transport {
    constructor(matchMaker) {
        this.matchMaker = matchMaker;
    }
    onMessageMatchMaking(client, message) {
        if (!message) {
            Debug_1.debugError(`couldn't decode message: ${message}`);
            return;
        }
        if (message[0] === Protocol_1.Protocol.JOIN_ROOM) {
            const roomName = message[1];
            const joinOptions = message[2];
            joinOptions.clientId = client.id;
            if (!this.matchMaker.hasHandler(roomName) && !__1.isValidId(roomName)) {
                Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomName, `Error: no available handler for "${roomName}"`]);
            }
            else {
                //
                // As a room might stop responding during the matchmaking process, due to it being disposed.
                // The last step of the matchmaking will make sure a seat will be reserved for this client
                // If `onJoinRoomRequest` can't make it until the very last step, a retry is necessary.
                //
                Utils_1.retry(() => {
                    return this.matchMaker.onJoinRoomRequest(client, roomName, joinOptions);
                }, 3, 0, [Errors_1.MatchMakeError]).
                    then((roomId) => {
                    Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ROOM, roomId, joinOptions.requestId]);
                }).catch((e) => {
                    Debug_1.debugError(e.stack || e);
                    Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomName, e && e.message]);
                });
            }
        }
        else if (message[0] === Protocol_1.Protocol.ROOM_LIST) {
            const requestId = message[1];
            const roomName = message[2];
            this.matchMaker.getAvailableRooms(roomName).
                then((rooms) => Protocol_1.send(client, [Protocol_1.Protocol.ROOM_LIST, requestId, rooms])).
                catch((e) => Debug_1.debugError(e.stack || e));
        }
        else {
            Debug_1.debugError(`MatchMaking couldn\'t process message: ${message}`);
        }
    }
}
exports.Transport = Transport;
var TCPTransport_1 = require("./TCPTransport");
exports.TCPTransport = TCPTransport_1.TCPTransport;
var WebSocketTransport_1 = require("./WebSocketTransport");
exports.WebSocketTransport = WebSocketTransport_1.WebSocketTransport;
