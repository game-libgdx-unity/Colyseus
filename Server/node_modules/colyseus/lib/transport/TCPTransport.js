"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const net = require("net");
const _1 = require("../");
const Protocol_1 = require("../Protocol");
const Transport_1 = require("./Transport");
const Debug_1 = require("./../Debug");
class TCPTransport extends Transport_1.Transport {
    constructor(matchMaker, options = {}) {
        super(matchMaker);
        this.onConnection = (client) => {
            // compatibility with ws / uws
            const upgradeReq = {};
            // set client id
            client.id = upgradeReq.colyseusid || _1.generateId();
            client.pingCount = 0;
            // ensure client has its "colyseusid"
            if (!upgradeReq.colyseusid) {
                Protocol_1.send(client, [Protocol_1.Protocol.USER_ID, client.id]);
            }
            // set client options
            client.options = upgradeReq.options;
            client.auth = upgradeReq.auth;
            // prevent server crashes if a single client had unexpected error
            client.on('error', (err) => Debug_1.debugError(err.message + '\n' + err.stack));
            // client.on('pong', heartbeat);
            client.on('data', (data) => this.onMessage(client, Protocol_1.decode(data)));
        };
        this.server = net.createServer();
        this.server.on('connection', this.onConnection);
    }
    listen(port, hostname, backlog, listeningListener) {
        this.server.listen(port, hostname, backlog, listeningListener);
        return this;
    }
    shutdown() {
        this.server.close();
    }
    onMessage(client, message) {
        console.log("RECEIVED:", message);
        if (message[0] === Protocol_1.Protocol.JOIN_ROOM &&
            _1.isValidId(message[1]) &&
            _1.isValidId(message[3])) {
            const roomId = message[1];
            client.id = message[3];
            client.options = message[2];
            console.log("EFFECTIVELY CONNECT INTO ROOM", roomId, client.id, client.options);
            client.removeAllListeners('data');
            // forward as 'message' all 'data' messages
            client.on('data', (data) => client.emit('message', data));
            this.matchMaker.connectToRoom(client, roomId).
                catch((e) => {
                Debug_1.debugError(e.stack || e);
                Protocol_1.send(client, [Protocol_1.Protocol.JOIN_ERROR, roomId, e && e.message]);
            });
        }
        else {
            this.onMessageMatchMaking(client, message);
        }
    }
}
exports.TCPTransport = TCPTransport;
