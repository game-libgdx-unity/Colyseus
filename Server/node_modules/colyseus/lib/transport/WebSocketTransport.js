"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const parseURL = require("url-parse");
const __1 = require("..");
const Transport_1 = require("./Transport");
const Utils_1 = require("../Utils");
const MatchMaker_1 = require("../MatchMaker");
const Protocol_1 = require("../Protocol");
const Debug_1 = require("./../Debug");
function noop() { }
function heartbeat() { this.pingCount = 0; }
class WebSocketTransport extends Transport_1.Transport {
    constructor(matchMaker, options = {}, engine) {
        super(matchMaker);
        this.verifyClient = (info, next) => __awaiter(this, void 0, void 0, function* () {
            const req = info.req;
            const url = parseURL(req.url);
            req.roomId = url.pathname.substr(1);
            const query = Utils_1.parseQueryString(url.query);
            req.colyseusid = query.colyseusid;
            delete query.colyseusid;
            req.options = query;
            if (req.roomId) {
                try {
                    // TODO: refactor me. this piece of code is repeated on MatchMaker class.
                    const hasReservedSeat = query.sessionId && (yield this.matchMaker.remoteRoomCall(req.roomId, 'hasReservedSeat', [query.sessionId]));
                    if (!hasReservedSeat) {
                        const isLocked = yield this.matchMaker.remoteRoomCall(req.roomId, 'locked');
                        if (isLocked) {
                            return next(false, __1.Protocol.WS_TOO_MANY_CLIENTS, 'maxClients reached.');
                        }
                    }
                    // verify client from room scope.
                    const authResult = yield this.matchMaker.remoteRoomCall(req.roomId, 'onAuth', [req.options], MatchMaker_1.REMOTE_ROOM_LARGE_TIMEOUT);
                    if (authResult) {
                        req.auth = authResult;
                        next(true);
                    }
                    else {
                        throw new Error('onAuth failed.');
                    }
                }
                catch (e) {
                    Debug_1.debugError(e.message + '\n' + e.stack);
                    next(false);
                }
            }
            else {
                next(true);
            }
        });
        this.onConnection = (client, req) => {
            // compatibility with ws / uws
            const upgradeReq = req || client.upgradeReq || {};
            // set client id
            client.id = upgradeReq.colyseusid || __1.generateId();
            client.pingCount = 0;
            // ensure client has its "colyseusid"
            if (!upgradeReq.colyseusid) {
                Protocol_1.send(client, [__1.Protocol.USER_ID, client.id]);
            }
            // set client options
            client.options = upgradeReq.options;
            client.auth = upgradeReq.auth;
            // prevent server crashes if a single client had unexpected error
            client.on('error', (err) => Debug_1.debugError(err.message + '\n' + err.stack));
            client.on('pong', heartbeat);
            const roomId = upgradeReq.roomId;
            if (roomId) {
                this.matchMaker.connectToRoom(client, upgradeReq.roomId).
                    catch((e) => {
                    Debug_1.debugError(e.stack || e);
                    Protocol_1.send(client, [__1.Protocol.JOIN_ERROR, roomId, e && e.message]);
                });
            }
            else {
                client.on('message', (data) => this.onMessageMatchMaking(client, Protocol_1.decode(data)));
            }
        };
        this.pingTimeout = options.pingTimeout || 1500;
        const customVerifyClient = options.verifyClient;
        options.verifyClient = (info, next) => {
            if (!customVerifyClient) {
                return this.verifyClient(info, next);
            }
            customVerifyClient(info, (verified, code, message) => {
                if (!verified) {
                    return next(verified, code, message);
                }
                this.verifyClient(info, next);
            });
        };
        this.wss = new engine(options);
        this.wss.on('connection', this.onConnection);
        this.server = options.server;
        // interval to detect broken connections
        this.pingInterval = setInterval(() => {
            this.wss.clients.forEach((client) => {
                //
                // if client hasn't responded after the interval, terminate its connection.
                //
                if (client.pingCount >= 2) {
                    return client.terminate();
                }
                client.pingCount++;
                client.ping(noop);
            });
        }, this.pingTimeout);
    }
    listen(port, hostname, backlog, listeningListener) {
        this.server.listen(port, hostname, backlog, listeningListener);
        return this;
    }
    shutdown() {
        clearInterval(this.pingInterval);
        this.wss.close();
        this.server.close();
    }
}
exports.WebSocketTransport = WebSocketTransport;
